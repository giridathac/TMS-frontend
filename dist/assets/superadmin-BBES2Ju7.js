import{d as pe,r,c as u}from"./index-Bqden_Qr.js";import{s as o}from"./superadmin.service-ymcF6AST.js";const ge=pe("superadmin",()=>{const l=r([]),d=r([]),c=r([]),m=r([]),f=r({pending:0,approved:0,rejected:0}),p=r({pendingApprovals:0,activeTemples:0,totalUsers:0,rejectedTemples:0,newThisWeek:0}),y=r({pendingApprovals:0,activeTenants:0,totalUsers:0,rejectedTenants:0}),h=r(!1),_=r(!1),I=r(!1),F=r(!1),P=r(!1),R=r(!1),D=r(!1),v=r(!1),k=r(!1),g=r(null),w=r(null),b=r(null),A=r(null),T=r(null),N=r(null),C=r(null),i=r(null),j=r(null),O=u(()=>l.value.filter(s=>s.status==="PENDING"||s.status==="pending")),B=u(()=>l.value.filter(s=>s.status==="APPROVED"||s.status==="approved")),G=u(()=>l.value.filter(s=>s.status==="REJECTED"||s.status==="rejected")),$=u(()=>f.value.pending||O.value.length),H=u(()=>f.value.approved||B.value.length),z=u(()=>f.value.rejected||G.value.length),L=u(()=>p.value.pendingApprovals),M=u(()=>p.value.activeTemples),q=u(()=>p.value.rejectedTemples),K=u(()=>p.value.totalUsers),Q=u(()=>c.value.filter(s=>s.status==="active")),X=u(()=>c.value.filter(s=>s.status==="inactive")),Y=u(()=>{const s={};return c.value.forEach(e=>{var t;const a=((t=e.role)==null?void 0:t.role_name)||"unknown";s[a]||(s[a]=[]),s[a].push(e)}),s});async function S(){F.value=!0,A.value=null;try{console.log("Store: Fetching tenant approval counts...");const s=await o.getTenantApprovalCounts();s.success&&s.data?(f.value={pending:s.data.pending||0,approved:s.data.approved||0,rejected:s.data.rejected||0},console.log("Store: Updated tenant counts:",f.value),y.value.activeTenants=f.value.approved,y.value.rejectedTenants=f.value.rejected):(console.warn("Store: Failed to fetch tenant counts:",s.message),A.value=s.message||"Failed to fetch tenant counts")}catch(s){console.error("Store: Error fetching tenant counts:",s),A.value=s.message}finally{F.value=!1}}async function E(){P.value=!0,T.value=null;try{console.log("Store: Fetching temple approval counts...");const s=await o.getTempleApprovalCounts();s.success&&s.data?(p.value={pendingApprovals:s.data.pendingApprovals||0,activeTemples:s.data.activeTemples||0,totalUsers:s.data.totalUsers||0,rejectedTemples:s.data.rejectedTemples||0,newThisWeek:s.data.newThisWeek||0},console.log("Store: Updated temple counts:",p.value),y.value.pendingApprovals=p.value.pendingApprovals,y.value.totalUsers=p.value.totalUsers):(console.warn("Store: Failed to fetch temple counts:",s.message),T.value=s.message||"Failed to fetch temple counts")}catch(s){console.error("Store: Error fetching temple counts:",s),T.value=s.message}finally{P.value=!1}}async function J(){I.value=!0,b.value=null;try{await Promise.all([S(),E()]),console.log("Store: All stats updated")}catch(s){console.error("Store: Error fetching combined stats:",s),b.value=s.message}finally{I.value=!1}}async function V(){h.value=!0,g.value=null;try{console.log("Store: Fetching tenants...");const s=await o.getPendingTenants();console.log("Store: Got response:",s),s.success&&Array.isArray(s.data)?(console.log("Store: Setting",s.data.length,"tenants"),l.value=s.data.map(e=>({id:e.id,fullName:e.full_name||e.fullName||e.name||"",name:e.name||e.fullName||e.full_name||"",email:e.email||"",phone:e.phone||"",status:(e.status||"PENDING").toUpperCase(),createdAt:e.created_at||e.createdAt||new Date().toISOString(),updatedAt:e.updated_at||e.updatedAt,rejectionNotes:e.rejection_notes||e.rejectionNotes,temple:e.temple?{name:e.temple.name,type:e.temple.type||"Hindu Temple",address:e.temple.address,city:e.temple.city,state:e.temple.state}:{name:e.name||e.fullName||e.full_name||"Unknown Temple",type:"Hindu Temple",address:e.address||"No address provided",city:e.city||"Unknown",state:e.state||"Unknown"},documents:e.documents||[]}))):(console.log("Store: Empty or invalid response"),l.value=[],g.value="No tenant data available")}catch(s){console.error("Store: Error fetching tenants:",s),g.value=s.message}finally{h.value=!1}}async function Z(){h.value=!0,g.value=null;try{console.log("Store: Fetching tenants for reports...");const s=await o.getTempleadminsForReports();return console.log("Store: Raw API response for reports:",s),s&&s.success&&Array.isArray(s.data)?(console.log("Store: First tenant raw data:",JSON.stringify(s.data[0],null,2)),l.value=s.data.map(e=>{const a=e.id||e.ID;console.log(`Tenant ${a} temple data:`,e.temple,"temple_details:",e.temple_details);const t={id:a,fullName:e.full_name||e.fullName||e.FullName||e.name||"",name:e.name||e.fullName||e.full_name||e.FullName||"",email:e.email||e.Email||"",phone:e.phone||e.Phone||"",status:(e.status||e.Status||"active").toString().toLowerCase(),createdAt:e.created_at||e.createdAt||e.CreatedAt||new Date().toISOString(),updatedAt:e.updated_at||e.updatedAt||e.UpdatedAt,temple_details:e.temple_details||e.templeDetails||{}};return e.temple_details?t.temple={name:e.temple_details.temple_name||"",city:e.temple_details.temple_place||"",state:""}:e.temple&&(t.temple=e.temple),console.log(`Mapped tenant ${a}:`,t),t}),console.log("Store: Final mapped tenants count:",l.value.length),{success:!0,data:l.value}):(console.log("Store: Empty or invalid response for reports tenants"),l.value=[],g.value="No tenant data available for reports",{success:!1,error:"No tenant data available for reports"})}catch(s){return console.error("Store: Error fetching tenants for reports:",s),g.value=s.message,{success:!1,error:s.message}}finally{h.value=!1}}async function W(){_.value=!0,w.value=null;try{const s=await o.getPendingEntities();s.success&&Array.isArray(s.data)?d.value=s.data:(d.value=[],w.value="No entity data available")}catch(s){console.error("Error fetching pending entities:",s),w.value=s.message}finally{_.value=!1}}async function ee(s,e={}){try{const a=await o.approveTenant(s,e);if(a.success){const t=l.value.findIndex(n=>n.id===s);return t!==-1&&(l.value[t].status="APPROVED",l.value[t].updatedAt=new Date().toISOString()),await S(),{success:!0}}return{success:!1,error:a.message}}catch(a){return{success:!1,error:a.message}}}async function se(s,e={}){try{const a=await o.rejectTenant(s,e);if(a.success){const t=l.value.findIndex(n=>n.id===s);return t!==-1&&(l.value[t].status="REJECTED",l.value[t].rejectionNotes=e.notes,l.value[t].updatedAt=new Date().toISOString()),await S(),{success:!0}}return{success:!1,error:a.message}}catch(a){return{success:!1,error:a.message}}}async function ae(s,e={}){try{const a=await o.approveEntity(s,e);if(a.success){const t=d.value.findIndex(n=>n.id===s);return t!==-1&&(d.value[t].status="APPROVED",d.value[t].updatedAt=new Date().toISOString()),await E(),{success:!0}}return{success:!1,error:a.message}}catch(a){return{success:!1,error:a.message}}}async function te(s,e={}){try{const a=await o.rejectEntity(s,e);if(a.success){const t=d.value.findIndex(n=>n.id===s);return t!==-1&&(d.value[t].status="REJECTED",d.value[t].rejectionNotes=e.notes,d.value[t].updatedAt=new Date().toISOString()),await E(),{success:!0}}return{success:!1,error:a.message}}catch(a){return{success:!1,error:a.message}}}async function x(){D.value=!0,C.value=null;try{console.log("Store: Fetching user roles...");const s=await o.getUserRoles();s.success&&Array.isArray(s.data)?(m.value=s.data,console.log("Store: User roles loaded:",m.value)):(m.value=[],C.value=s.message||"No user roles available")}catch(s){console.error("Store: Error fetching user roles:",s),C.value=s.message,m.value=[]}finally{D.value=!1}}async function U(s={}){R.value=!0,N.value=null;try{console.log("Store: Fetching users with filters:",s);const e=await o.getUsers(s);e.success&&Array.isArray(e.data)?(c.value=e.data,console.log("Store: Users loaded:",c.value.length,"users")):(c.value=[],N.value=e.message||"No users available")}catch(e){console.error("Store: Error fetching users:",e),N.value=e.message,c.value=[]}finally{R.value=!1}}async function re(s){v.value=!0,i.value=null;try{console.log("Store: Fetching user by ID:",s);const e=await o.getUserById(s);return e.success&&e.data?{success:!0,data:e.data}:{success:!1,error:e.message||"User not found"}}catch(e){return console.error("Store: Error fetching user by ID:",e),i.value=e.message,{success:!1,error:e.message}}finally{v.value=!1}}async function le(s){v.value=!0,i.value=null;try{console.log("Store: Creating user:",s);const e=await o.createUser(s);return e.success?(await U(),{success:!0,message:"User created successfully"}):(i.value=e.message,{success:!1,error:e.message})}catch(e){return console.error("Store: Error creating user:",e),i.value=e.message,{success:!1,error:e.message}}finally{v.value=!1}}async function oe(s,e){v.value=!0,i.value=null;try{console.log("Store: Updating user:",s,e);const a=await o.updateUser(s,e);if(a.success){const t=c.value.findIndex(n=>n.id===s);if(t!==-1){const n=await o.getUserById(s);n.success&&(c.value[t]=n.data)}return{success:!0,message:"User updated successfully"}}else return i.value=a.message,{success:!1,error:a.message}}catch(a){return console.error("Store: Error updating user:",a),i.value=a.message,{success:!1,error:a.message}}finally{v.value=!1}}async function ne(s,e){v.value=!0,i.value=null;try{console.log("Store: Updating user status:",s,e);const a=await o.updateUserStatus(s,e);if(a.success){const t=c.value.findIndex(n=>n.id===s);return t!==-1&&(c.value[t].status=e),{success:!0,message:`User status updated to ${e}`}}else return i.value=a.message,{success:!1,error:a.message}}catch(a){return console.error("Store: Error updating user status:",a),i.value=a.message,{success:!1,error:a.message}}finally{v.value=!1}}async function ue(s){k.value=!0,j.value=null;try{console.log("Store: Starting bulk upload of",s.length,"users...");const e=await o.bulkUploadUsers(s);return e.success?(await U(),{success:!0,data:e.data,message:e.message||"Bulk upload completed successfully"}):(j.value=e.message,{success:!1,data:e.data,error:e.message})}catch(e){return console.error("Store: Error during bulk upload:",e),j.value=e.message,{success:!1,data:null,error:e.message}}finally{k.value=!1}}function ce(){J(),V(),W(),x(),U()}async function ie(){await Promise.all([S(),E()])}async function de(){await Promise.all([x(),U()])}return{tenants:l,pendingEntities:d,stats:y,tenantCounts:f,templeCounts:p,users:c,userRoles:m,loadingTenants:h,loadingEntities:_,loadingStats:I,loadingTenantCounts:F,loadingTempleCounts:P,loadingUsers:R,loadingUserRoles:D,loadingUserAction:v,loadingBulkUpload:k,tenantError:g,entityError:w,statsError:b,tenantCountsError:A,templeCountsError:T,userError:N,userRolesError:C,userActionError:i,bulkUploadError:j,pendingTenants:O,approvedTenants:B,rejectedTenants:G,pendingCount:$,activeCount:H,rejectedCount:z,templePendingCount:L,templeActiveCount:M,templeRejectedCount:q,totalUsersCount:K,activeUsers:Q,inactiveUsers:X,usersByRole:Y,fetchTenants:V,fetchPendingEntities:W,fetchStats:J,fetchTenantCounts:S,fetchTempleCounts:E,refreshCounts:ie,approveTenant:ee,rejectTenant:se,approveEntity:ae,rejectEntity:te,fetchTenantsForReports:Z,fetchUserRoles:x,fetchUsers:U,fetchUserById:re,createUser:le,updateUser:oe,updateUserStatus:ne,createBulkUsers:ue,refreshUserData:de,initialize:ce}});export{ge as u};
